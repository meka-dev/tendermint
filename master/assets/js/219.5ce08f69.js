(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{793:function(e,t,a){"use strict";a.r(t);var i=a(1),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"light-client-attack-detector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#light-client-attack-detector"}},[e._v("#")]),e._v(" Light Client Attack Detector")]),e._v(" "),a("p",[e._v('In this specification, we strengthen the light client to be resistant\nagainst so-called light client attacks. In a light client attack, all\nthe correct Tendermint full nodes agree on the sequence of generated\nblocks (no fork), but a set of faulty full nodes attack a light client\nby generating (signing) a block that deviates from the block of the\nsame height on the blockchain. In order to do so, some of these faulty\nfull nodes must have been validators before and violate the assumption\nof more than two thirds of "correct voting power"\n'),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v(", as otherwise, if\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v(" would hold,\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v(" would satisfy\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-seq-safe1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-SEQ-SAFE.1]"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("An attack detector (or detector for short) is a mechanism that is used\nby the light client "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor_001_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("supervisor"),a("OutboundLink")],1),e._v(" after\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v(" of a new light block\nwith the primary, to cross-check the newly learned light block with\nother peers (secondaries).  It expects as input a light block with some\nheight "),a("em",[e._v("root")]),e._v(" (that serves as a root of trust), and a verification\ntrace (a sequence of lightblocks) that the primary provided.")]),e._v(" "),a("p",[e._v("In case the detector observes a light client attack, it computes\nevidence data that can be used by Tendermint full nodes to isolate a\nset of faulty full nodes that are still within the unbonding period\n(more than 1/3 of the voting power of the validator set at some block\nof the chain), and report them via ABCI (application/blockchain\ninterface)\nto the application of a\nTendermint blockchain in order to punish faulty nodes.")]),e._v(" "),a("h2",{attrs:{id:"context-of-this-document"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-of-this-document"}},[e._v("#")]),e._v(" Context of this document")]),e._v(" "),a("p",[e._v("The light client "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v(" specification is\ndesigned for the Tendermint failure model (1/3 assumption)\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v(".  It is safe under this\nassumption, and live if it can reliably (that is, no message loss, no\nduplication, and eventually delivered) and timely communicate with a\ncorrect full node. If "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v("\nassumption is violated, the light client can be fooled to trust a\nlight block that was not generated by Tendermint consensus.")]),e._v(" "),a("p",[e._v('This specification, the attack detector, is a "second line of\ndefense", in case the 1/3 assumption is violated.  Its goal is to\ndetect a light client attack (conflicting light blocks) and collect\nevidence. However, it is impractical to probe all full nodes. At this\ntime we consider a simple scheme of maintaining an address book of\nknown full nodes from which a small subset (e.g., 4) are chosen\ninitially to communicate with. More involved book keeping with\nprobabilistic guarantees can be considered at later stages of the\nproject.')]),e._v(" "),a("p",[e._v("The light client maintains a simple address book containing addresses\nof full nodes that it can pick as primary and secondaries.  To obtain\na new light block, the light client first does\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v(" with the primary, and then cross-checks\nthe light block (and the trace of light blocks that led to it) with\nthe secondaries using this specification.")]),e._v(" "),a("h1",{attrs:{id:"outline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[e._v("#")]),e._v(" Outline")]),e._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"#part-i---Tendermint-Consensus-and-Light-Client-Attacks"}},[e._v("Part I")]),e._v(":\nFormal definitions of lightclient attacks, based on basic\nproperties of Tendermint consensus.")]),e._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"#Node-based-characterization-of-attacks"}},[e._v("Node-based characterization of\nattacks")]),e._v(". The\ndefinition of attacks used in the problem statement of\nthis specification.")])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#Block-based-characterization-of-attacks"}},[e._v("Block-based characterization of attacks")]),e._v(". Alternative definitions\nprovided for future reference.")])])])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#part-ii---problem-statement"}},[e._v("Part II")]),e._v(": Problem statement of\nlightclient attack detection")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#informal-problem-statement"}},[e._v("Informal Problem Statement")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Assumptions"}},[e._v("Assumptions")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#definitions"}},[e._v("Definitions")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Distributed-Problem-statement"}},[e._v("Distributed Problem statement")])])])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#part-iii---protocol"}},[e._v("Part III")]),e._v(": The protocol")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Functions-and-Data-defined-in-other-Specifications"}},[e._v("Functions and Data defined in other Specifications")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Outline-of-solution"}},[e._v("Outline of Solution")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Details-of-the-functions"}},[e._v("Details of the functions")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Correctness-arguments"}},[e._v("Correctness arguments")])])])])]),e._v(" "),a("h1",{attrs:{id:"part-i-tendermint-consensus-and-light-client-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#part-i-tendermint-consensus-and-light-client-attacks"}},[e._v("#")]),e._v(" Part I - Tendermint Consensus and Light Client Attacks")]),e._v(" "),a("p",[e._v("In this section we will give some mathematical definitions of what we\nmean by light client attacks (that are considered in this\nspecification) and how they differ from main-chain forks. To this end,\nwe start by defining some properties of the sequence of blocks that is\ndecided upon by Tendermint consensus in normal operation (if the\nTendermint failure model holds\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v("),\nand then define different\ndeviations that correspond to attack scenarios. We consider the notion\nof "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-data-lightblock1",target:"_blank",rel:"noopener noreferrer"}},[e._v("light blocks"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-header-fields2",target:"_blank",rel:"noopener noreferrer"}},[e._v("headers"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"tmbc-genesis-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-genesis-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-GENESIS.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("Genesis")]),e._v(" be the agreed-upon initial block (file).")]),e._v(" "),a("h4",{attrs:{id:"tmbc-func-sign-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-func-sign-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-FUNC-SIGN.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be two light blocks with "),a("em",[e._v("b.Header.Height + 1 =\nc.Header.Height")]),e._v(". We define the predicate "),a("strong",[e._v("signs(b,c)")]),e._v(" to hold\niff "),a("em",[e._v("c.Header.LastCommit")]),e._v(" is in "),a("em",[e._v("PossibleCommit(b)")]),e._v(".\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-sound-distr-poss-commit1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-SOUND-DISTR-POSS-COMMIT.1]"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The above encodes sequential verification, that is, intuitively,\nb.Header.NextValidators = c.Header.Validators and 2/3 of\nthese Validators signed c.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-func-support-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-func-support-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-FUNC-SUPPORT.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be two light blocks. We define the predicate\n"),a("strong",[e._v("supports(b,c,t)")]),e._v(" to hold iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("t - trustingPeriod < b.Header.Time < t")])]),e._v(" "),a("li",[e._v("the voting power in "),a("em",[e._v("b.NextValidators")]),e._v(" of nodes in "),a("em",[e._v("c.Commit")]),e._v("\nis more than 1/3 of "),a("em",[e._v("TotalVotingPower(b.Header.NextValidators)")])])]),e._v(" "),a("blockquote",[a("p",[e._v("That is, if the "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint failure model"),a("OutboundLink")],1),e._v("\nholds, then "),a("em",[e._v("c")]),e._v(" has been signed by at least one correct full node, cf.\n"),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-val-contains-corr1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-VAL-CONTAINS-CORR.1]"),a("OutboundLink")],1),e._v(".\nThe following formalizes that "),a("em",[e._v("b")]),e._v(" was properly generated by\nTendermint; "),a("em",[e._v("b")]),e._v(" can be traced back to genesis.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-seq-rooted-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-seq-rooted-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SEQ-ROOTED.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" be a light block.\nWe define "),a("em",[e._v("sequ-rooted(b)")]),e._v(" iff for all "),a("em",[e._v("i")]),e._v(", "),a("em",[e._v("1 <= i < h = b.Header.Height")]),e._v(",\nthere exist light blocks "),a("em",[e._v("a(i)")]),e._v(" s.t.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("a(1) = Genesis")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("a(h) = b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("signs( a(i) , a(i+1) )")]),e._v(".")])]),e._v(" "),a("blockquote",[a("p",[e._v("The following formalizes that "),a("em",[e._v("c")]),e._v(" is trusted based on "),a("em",[e._v("b")]),e._v(" in\nskipping verification. Observe that we do not require here (yet)\nthat "),a("em",[e._v("b")]),e._v(" was properly generated.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-skip-trace-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-skip-trace-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SKIP-TRACE.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be light blocks. We define "),a("em",[e._v("skip-trace(b,c,t)")]),e._v(" if at\ntime t there exists an integer "),a("em",[e._v("h")]),e._v(" and a sequence "),a("em",[e._v("a(1)")]),e._v(", ... "),a("em",[e._v("a(h)")]),e._v(" s.t.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("a(1) = b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("a(h) = c")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("supports( a(i), a(i+1), t)")]),e._v(", for all i, "),a("em",[e._v("1 <= i < h")]),e._v(".")])]),e._v(" "),a("p",[e._v("We call such a sequence "),a("em",[e._v("a(1)")]),e._v(", ... "),a("em",[e._v("a(h)")]),e._v(" a "),a("strong",[e._v("verification trace")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The following formalizes that two light blocks of the same height\nshould agree on the content of the header. Observe that "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v("\nmay disagree on the Commit. This is a special case if the canonical\ncommit has not been decided on yet, that is, if b.Header.Height is the\nmaximum height of all blocks decided upon by Tendermint at this\nmoment.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-sign-skip-match-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-sign-skip-match-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SIGN-SKIP-MATCH.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("b")]),e._v(", "),a("em",[e._v("c")]),e._v(", be light blocks and "),a("em",[e._v("t")]),e._v(" a time, we define\n"),a("em",[e._v("sign-skip-match(a,b,c,t) = true")]),e._v(" iff the following implication\nevaluates to true:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sequ-rooted(a)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("b.Header.Height = c.Header.Height")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,b,t)")])]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,c,t)")])])]),e._v(" "),a("p",[e._v("implies "),a("em",[e._v("b.Header = c.Header")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("Observe that "),a("em",[e._v("sign-skip-match")]),e._v(" is defined via an implication. If it\nevaluates to false this means that the left-hand-side of the\nimplication evaluates to true, and the right-hand-side evaluates to\nfalse. In particular, there are two "),a("strong",[e._v("different")]),e._v(" headers "),a("em",[e._v("b")]),e._v(" and\n"),a("em",[e._v("c")]),e._v(" that both can be verified from a common block "),a("em",[e._v("a")]),e._v(" from the\nchain. Thus, the following describes an attack.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If there exists three light blocks a, b, and c, with\n"),a("em",[e._v("sign-skip-match(a,b,c,t) = false")]),e._v(" then we have an "),a("em",[e._v("attack")]),e._v(".  We say\nwe have "),a("strong",[e._v("an attack at height")]),e._v(" "),a("em",[e._v("b.Header.Height")]),e._v(" and write\n"),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The lightblock "),a("em",[e._v("a")]),e._v(" need not be unique, that is, there may be\nseveral blocks that satisfy the above requirement for the same\nblocks "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(".")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#TMBC-ATTACK1"}},[e._v("[TMBC-ATTACK.1]")]),e._v(" is a formalization of the violation\nof the agreement property based on the result of consensus, that is,\nthe generated blocks.")]),e._v(" "),a("p",[a("strong",[e._v("Remark.")]),e._v('\nViolation of agreement is only possible if more than 1/3 of the validators (or\nnext validators) of some previous block deviated from the protocol. The\nupcoming "accountability" specification will describe how to compute\na set of at least 1/3 faulty nodes from two conflicting blocks. []')]),e._v(" "),a("p",[e._v('There are different ways to characterize forks\nand attack scenarios. This specification uses the "node-based\ncharacterization of attacks" which focuses on what kinds of nodes are\naffected (light nodes vs. full nodes). For future reference and\ndiscussion we also provide a\n"block-based characterization of attacks" below.')]),e._v(" "),a("h2",{attrs:{id:"node-based-characterization-of-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-based-characterization-of-attacks"}},[e._v("#")]),e._v(" Node-based characterization of attacks")]),e._v(" "),a("h4",{attrs:{id:"tmbc-mc-fork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-mc-fork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-MC-FORK.1]")])]),e._v(" "),a("p",[e._v("We say there is a (main chain) fork at time "),a("em",[e._v("t")]),e._v(" if")]),e._v(" "),a("ul",[a("li",[e._v("there are two correct full nodes "),a("em",[e._v("i")]),e._v(" and "),a("em",[e._v("j")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("i")]),e._v(" is different from "),a("em",[e._v("j")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("i")]),e._v(" has decided on "),a("em",[e._v("b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("j")]),e._v(" has decided on "),a("em",[e._v("c")]),e._v(" and")]),e._v(" "),a("li",[e._v("there exist "),a("em",[e._v("a")]),e._v(" such that "),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-ATTACK.1]")])]),e._v(" "),a("p",[e._v("We say there is a light client attack at time "),a("em",[e._v("t")]),e._v(", if")]),e._v(" "),a("ul",[a("li",[e._v("there is "),a("strong",[e._v("no")]),e._v(" (main chain) fork "),a("a",{attrs:{href:"#TMBC-MC-FORK1"}},[e._v("[TMBC-MC-FORK.1]")]),e._v(", and")]),e._v(" "),a("li",[e._v("there exist nodes that have computed light blocks "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" and")]),e._v(" "),a("li",[e._v("there exist "),a("em",[e._v("a")]),e._v(" such that "),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")])]),e._v(" "),a("p",[e._v("We say the attack is at height "),a("em",[e._v("a.Header.Height")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("In this specification we consider detection of light client\nattacks. Intuitively, the case we consider is that\nlight block "),a("em",[e._v("b")]),e._v(" is the one from the\nblockchain, and some attacker has computed "),a("em",[e._v("c")]),e._v(" and tries to wrongly\nconvince\nthe light client that "),a("em",[e._v("c")]),e._v(" is the block from the chain.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-attack-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-attack-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-ATTACK-EVIDENCE.1]")])]),e._v(" "),a("p",[e._v("We consider the following case of a light client attack\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("attack(a,b,c,t)")])]),e._v(" "),a("li",[e._v("there is a peer p1 that has a sequence "),a("em",[e._v("chain")]),e._v(" of blocks from "),a("em",[e._v("a")]),e._v(" to "),a("em",[e._v("b")])]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,c,t)")]),e._v(": by "),a("a",{attrs:{href:"#TMBC-SKIP-TRACE1"}},[e._v("[TMBC-SKIP-TRACE.1]")]),e._v(" there is a\nverification trace "),a("em",[e._v("v")]),e._v(" of the form "),a("em",[e._v("a = v(1)")]),e._v(", ... "),a("em",[e._v("v(h) = c")])])]),e._v(" "),a("p",[e._v("Evidence for p1 (that proves an attack to p1) consists for index i\nof v(i) and v(i+1) such that")]),e._v(" "),a("ul",[a("li",[e._v("E1(i). v(i) is equal to the block of "),a("em",[e._v("chain")]),e._v(" at height v(i).Height, and")]),e._v(" "),a("li",[e._v("E2(i). v(i+1) that is different from  the block of "),a("em",[e._v("chain")]),e._v(" at\nheight v(i+1).height")])]),e._v(" "),a("blockquote",[a("p",[e._v("Observe p1 can")]),e._v(" "),a("ul",[a("li",[e._v("check that v(i+1)  differs from its block at that height, and")]),e._v(" "),a("li",[e._v("verify v(i+1) in one step from v(i) as v is a verification trace.")])])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-evidence-data-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-evidence-data-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-EVIDENCE-DATA.1]")])]),e._v(" "),a("p",[e._v("To prove the attack to p1, because of Point E1, it is sufficient to\nsubmit")]),e._v(" "),a("ul",[a("li",[e._v("v(i).Height (rather than v(i)).")]),e._v(" "),a("li",[e._v("v(i+1)")])]),e._v(" "),a("p",[e._v("This information is "),a("em",[e._v("evidence for height v(i).Height")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"block-based-characterization-of-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-based-characterization-of-attacks"}},[e._v("#")]),e._v(" Block-based characterization of attacks")]),e._v(" "),a("p",[e._v("In this section we provide a different characterization of attacks. It\nis not defined on the nodes that are affected but purely on the\ncontent of the blocks. In that sense these definitions are less\noperational.")]),e._v(" "),a("blockquote",[a("p",[e._v("They might be relevant for a closer analysis of fork scenarios on the\nchain, which is out of the scope of this specification.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-sign-unique-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-sign-unique-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SIGN-UNIQUE.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be  light blocks, we define the predicate\n"),a("em",[e._v("sign-unique(b,c)")]),e._v(" to evaluate to true iff the following implication\nevaluates to true:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("b.Header.Height =  c.Header.Height")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(b)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(c)")])])]),e._v(" "),a("p",[e._v("implies "),a("em",[e._v("b = c")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"tmbc-blocks-mcfork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-blocks-mcfork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BLOCKS-MCFORK.1]")])]),e._v(" "),a("p",[e._v("If there exists two light blocks b and c, with "),a("em",[e._v("sign-unique(b,c) =\nfalse")]),e._v(" then we have a "),a("em",[e._v("fork")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The difference of the above definition to\n"),a("a",{attrs:{href:"#TMBC-MC-FORK1"}},[e._v("[TMBC-MC-FORK.1]")]),e._v(" is subtle. The latter requires a\nfull node being affected by a bad block while\n"),a("a",{attrs:{href:"#TMBC-BLOCKS-MCFORK1"}},[e._v("[TMBC-BLOCKS-MCFORK.1]")]),e._v(" just requires that a\nbad block exists, possibly in memory of an attacker.\nThe following captures a light client fork. There is no fork up to\nthe height of block b. However, c is of that height, is different,\nand passes skipping verification. It is a stricter property than\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(", as\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(" requires that no correct full\nnode is affected.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-blocks-lcfork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-blocks-lcfork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BLOCKS-LCFORK.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("b")]),e._v(", "),a("em",[e._v("c")]),e._v(", be light blocks and "),a("em",[e._v("t")]),e._v(" a time. We define\n"),a("em",[e._v("light-client-fork(a,b,c,t)")]),e._v(" iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sign-skip-match(a,b,c,t) = false")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(b)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("b")]),e._v(' is "unique", that is, for all '),a("em",[e._v("d")]),e._v(",  "),a("em",[e._v("sequ-rooted(d)")]),e._v(" and\n"),a("em",[e._v("d.Header.Height = b.Header.Height")]),e._v(" implies "),a("em",[e._v("d = b")])])]),e._v(" "),a("blockquote",[a("p",[e._v("Finally, let us also define bogus blocks that have no support.\nObserve that bogus is even defined if there is a fork.\nAlso, for the definition it would be sufficient to restrict "),a("em",[e._v("a")]),e._v(" to\n"),a("em",[e._v("a.height < b.height")]),e._v(" (which is implied by the definitions which\nunfold until "),a("em",[e._v("supports()")]),e._v(").")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-bogus-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BOGUS.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" be a light block and "),a("em",[e._v("t")]),e._v(" a time. We define "),a("em",[e._v("bogus(b,t)")]),e._v(" iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sequ-rooted(b) = false")]),e._v(" and")]),e._v(" "),a("li",[e._v("for all "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("sequ-rooted(a)")]),e._v(" implies "),a("em",[e._v("skip-trace(a,b,t) = false")])])]),e._v(" "),a("h1",{attrs:{id:"part-ii-problem-statement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#part-ii-problem-statement"}},[e._v("#")]),e._v(" Part II - Problem Statement")]),e._v(" "),a("h2",{attrs:{id:"informal-problem-statement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#informal-problem-statement"}},[e._v("#")]),e._v(" Informal Problem statement")]),e._v(" "),a("p",[e._v("There is no sequential specification: the detector only makes sense\nin a distributed systems where some nodes misbehave.")]),e._v(" "),a("p",[e._v("We work under the assumption that full nodes and validators are\nresponsible for detecting attacks on the main chain, and the evidence\nreactor takes care of broadcasting evidence to communicate\nmisbehaving nodes via ABCI to the application, and halt the chain in\ncase of a fork. The point of this specification is to shield a light\nclients against attacks that cannot be detected by full nodes, and\nare fully addressed at light clients (and consequently IBC relayers,\nwhich use the light client protocols to observe the state of a\nblockchain). In order to provide full nodes the incentive to follow\nthe protocols when communicating with the light client, this\nspecification also considers the generation of evidence that will\nalso be processed by the Tendermint blockchain.")]),e._v(" "),a("h4",{attrs:{id:"lcd-ip-model-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-ip-model-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-IP-MODEL.1]")])]),e._v(" "),a("p",[e._v("The detector is designed under the assumption that")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#tmbc-fm-2thirds1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[TMBC-FM-2THIRDS]"),a("OutboundLink")],1),e._v(" may be violated")]),e._v(" "),a("li",[e._v("there is no fork on the main chain.")])]),e._v(" "),a("blockquote",[a("p",[e._v("As a result some faulty full nodes may launch an attack on a light\nclient.")])]),e._v(" "),a("p",[e._v("The following requirements are operational in that they describe how\nthings should be done, rather than what should be done. However, they\ndo not constitute temporal logic verification conditions. For those,\nsee [LCD-DIST-*] below.")]),e._v(" "),a("p",[e._v("The detector is called in the "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor_001_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("supervisor"),a("OutboundLink")],1),e._v(" as follows")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"RXZpZGVuY2VzIDo9IEF0dGFja0RldGVjdG9yKHJvb3Rfb2ZfdHJ1c3QsIHZlcmlmaWVkTFMpO2AK"}}),e._v(" "),a("p",[e._v("where")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("root-of-trust")]),e._v(" is a light block that is trusted (that is,\nexcept upon initialization, the primary and the secondaries\nagreed on in the past), and")]),e._v(" "),a("li",[a("code",[e._v("verifiedLS")]),e._v(" is a lightstore that contains a verification trace that\nstarts from a lightblock that can be verified with the\n"),a("code",[e._v("root-of-trust")]),e._v(" in one step and ends with a lightblock of the height\nrequested by the user")]),e._v(" "),a("li",[a("code",[e._v("Evidences")]),e._v(" is a list of evidences for misbehavior")])]),e._v(" "),a("h4",{attrs:{id:"lcd-ip-statement-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-ip-statement-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-IP-STATEMENT.1]")])]),e._v(" "),a("p",[e._v("Whenever AttackDetector is called, the detector should for each\nsecondary cross check the largest header in verifiedLS with the\ncorresponding header of the same height provided by the secondary. If\nthere is a deviation, the detector should\ntry to replay the verification trace "),a("code",[e._v("verifiedLS")]),e._v(" with the\nsecondary")]),e._v(" "),a("ul",[a("li",[e._v("in case replaying leads to detection of a light client attack\n(one of the lightblocks differ from the one in verifiedLS with\nthe same height), we should return evidence")]),e._v(" "),a("li",[e._v("if the secondary cannot provide a verification trace, we have no\nproof for an attack. Block "),a("em",[e._v("b")]),e._v(" may be bogus. In this case the\nsecondary is faulty and it should be replaced.")])]),e._v(" "),a("h2",{attrs:{id:"assumptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assumptions"}},[e._v("#")]),e._v(" Assumptions")]),e._v(" "),a("p",[e._v("It is not in the interest of faulty full nodes to talk to the\ndetector as long as the  detector is connected to at least one\ncorrect full node. This would only increase the likelihood of\nmisbehavior being detected. Also we cannot punish them easily\n(cheaply). The absence of a response need not be the fault of the full\nnode.")]),e._v(" "),a("p",[e._v("Correct full nodes have the incentive to respond, because the\ndetector may help them to understand whether their header is a good\none. We can thus base liveness arguments of the  detector on\nthe assumptions that correct full nodes reliably talk to the\ndetector.")]),e._v(" "),a("h4",{attrs:{id:"lcd-a-corrfull-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-a-corrfull-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-A-CorrFull.1]")])]),e._v(" "),a("p",[e._v("At all times there is at least one correct full\nnode among the primary and the secondaries.")]),e._v(" "),a("blockquote",[a("p",[e._v("For this version of the detection we take this assumption. It\nallows us to establish the invariant that the lightblock\n"),a("code",[e._v("root-of-trust")]),e._v(" is always the one from the blockchain, and we can\nuse it as starting point for the evidence computation. Moreover, it\nallows us to establish the invariant at the supervisor that any\nlightblock in the (top-level) lightstore is from the blockchain."),a("br"),e._v("\nIn the future we might design a lightclient based on the assumption\nthat at least in regular intervals the lightclient is connected to a\ncorrect full node. This will require the detector to reconsider\n"),a("code",[e._v("root-of-trust")]),e._v(", and remove lightblocks from the top-level\nlightstore.")])]),e._v(" "),a("h4",{attrs:{id:"lcd-a-relcomm-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-a-relcomm-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-A-RelComm.1]")])]),e._v(" "),a("p",[e._v("Communication between the  detector and a correct full node is\nreliable and bounded in time. Reliable communication means that\nmessages are not lost, not duplicated, and eventually delivered. There\nis a (known) end-to-end delay "),a("em",[e._v("Delta")]),e._v(", such that if a message is sent\nat time "),a("em",[e._v("t")]),e._v(" then it is received and processed by time "),a("em",[e._v("t + Delta")]),e._v(".\nThis implies that we need a timeout of at least "),a("em",[e._v("2 Delta")]),e._v(" for remote\nprocedure calls to ensure that the response of a correct peer arrives\nbefore the timeout expires.")]),e._v(" "),a("h2",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),a("h3",{attrs:{id:"evidence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#evidence"}},[e._v("#")]),e._v(" Evidence")]),e._v(" "),a("p",[e._v("Following the definition of\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK-EVIDENCE1"}},[e._v("[TMBC-LC-ATTACK-EVIDENCE.1]")]),e._v(", by evidence\nwe refer to a variable of the following type")]),e._v(" "),a("h4",{attrs:{id:"lc-data-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-data-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-DATA-EVIDENCE.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBMaWdodENsaWVudEF0dGFja0V2aWRlbmNlIHN0cnVjdCB7CiAgICBDb25mbGljdGluZ0Jsb2NrICAgTGlnaHRCbG9jawogICAgQ29tbW9uSGVpZ2h0ICAgICAgIGludDY0CgogICAgLy8gRXZpZGVuY2UgYWxzbyBpbmNsdWRlcyBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhIHdoaWNoIGlzIG5vdAogICAgLy8gcGFydCBvZiB2ZXJpZmljYXRpb24gYnV0IGlzIHNlbnQgdG8gdGhlIGFwcGxpY2F0aW9uIG9uY2UgdGhlCiAgICAvLyBldmlkZW5jZSBnZXRzIGNvbW1pdHRlZCBvbiBjaGFpbi4KfQo="}}),e._v(" "),a("p",[e._v("As the above data is computed for a specific peer, the following\ndata structure wraps the evidence and adds the peerID.")]),e._v(" "),a("h4",{attrs:{id:"lc-data-evidence-int-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-data-evidence-int-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-DATA-EVIDENCE-INT.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBJbnRlcm5hbEV2aWRlbmNlIHN0cnVjdCB7CiAgICBFdmlkZW5jZSAgICAgICAgICAgTGlnaHRDbGllbnRBdHRhY2tFdmlkZW5jZQogICAgUGVlciAgICAgICAgICAgICAgIFBlZXJJRAp9Cg=="}}),e._v(" "),a("h4",{attrs:{id:"lc-sumbit-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-sumbit-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-SUMBIT-EVIDENCE.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBzdWJtaXRFdmlkZW5jZShFdmlkZW5jZXMgW11JbnRlcm5hbEV2aWRlbmNlKQo="}}),e._v(" "),a("ul",[a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("for each "),a("code",[e._v("ev")]),e._v(" in "),a("code",[e._v("Evidences")]),e._v(": submit "),a("code",[e._v("ev.Evidence")]),e._v(" to "),a("code",[e._v("ev.Peer")])])])])]),e._v(" "),a("hr"),e._v(" "),a("h3",{attrs:{id:"lightstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lightstore"}},[e._v("#")]),e._v(" LightStore")]),e._v(" "),a("p",[e._v("Lightblocks and LightStores are defined in the verification\nspecification "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-data-lightblock1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-DATA-LIGHTBLOCK.1]"),a("OutboundLink")],1),e._v("\nand "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-data-lightstore2",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-DATA-LIGHTSTORE.2]"),a("OutboundLink")],1),e._v(". See\nthe "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification specification"),a("OutboundLink")],1),e._v(" for details.")]),e._v(" "),a("h2",{attrs:{id:"distributed-problem-statement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distributed-problem-statement"}},[e._v("#")]),e._v(" Distributed Problem statement")]),e._v(" "),a("blockquote",[a("p",[e._v("As the attack detector is there to reduce the impact of faulty\nnodes, and faulty nodes imply that there is a distributed system,\nthere is no sequential specification to which this distributed\nproblem statement may refer to.")])]),e._v(" "),a("p",[e._v("The detector gets as input a trusted lightblock called "),a("em",[e._v("root")]),e._v(" and an\nauxiliary lightstore called "),a("em",[e._v("primary_trace")]),e._v(" with lightblocks that have\nbeen verified before, and that were provided by the primary.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-inv-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-inv-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-INV-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If the detector returns evidence for height "),a("em",[e._v("h")]),e._v(" "),a("a",{attrs:{href:"#TMBC-LC-EVIDENCE-DATA1"}},[e._v("[TMBC-LC-EVIDENCE-DATA.1]")]),e._v(", then there is an\nattack at height "),a("em",[e._v("h")]),e._v(". "),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")])]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-inv-store-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-inv-store-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-INV-STORE.1]")])]),e._v(" "),a("p",[e._v("If the detector does not return evidence, then "),a("em",[e._v("primary_trace")]),e._v("\ncontains only blocks from the blockchain.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-live-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-live-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-LIVE.1]")])]),e._v(" "),a("p",[e._v("The detector eventually terminates.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-term-normal-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-term-normal-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("the "),a("em",[e._v("primary_trace")]),e._v(" contains only blocks from the blockchain, and")]),e._v(" "),a("li",[e._v("there is no attack, and")]),e._v(" "),a("li",[a("em",[e._v("Secondaries")]),e._v(" is always non-empty, and")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the detector does not return evidence.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-term-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-term-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-TERM-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("there is an attack, and")]),e._v(" "),a("li",[e._v("a secondary reports a block that conflicts\nwith one of the blocks in "),a("em",[e._v("primary_trace")]),e._v(", and")]),e._v(" "),a("li",[a("em",[e._v("Secondaries")]),e._v(" is always non-empty, and")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the detector returns evidence.")]),e._v(" "),a("blockquote",[a("p",[e._v('Observe that above we require that "a secondary reports a block that\nconflicts". If there is an attack, but no secondary tries to launch\nit against the detector (or the message from the secondary is lost\nby the network), then there is nothing to detect for us.')])]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-safe-secondary-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-safe-secondary-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-SAFE-SECONDARY.1]")])]),e._v(" "),a("p",[e._v("No correct secondary is ever replaced.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-safe-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-safe-bogus-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-SAFE-BOGUS.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("a secondary reports a bogus lightblock,")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the secondary is replaced before the detector terminates.")]),e._v(" "),a("blockquote",[a("p",[e._v('The above property is quite operational (e.g., the usage of\n"reports"), but it captures closely the requirement. As the\ndetector only makes sense in a distributed setting, and does not\nhave a sequential specification, a less "pure" specification are\nacceptable.')])]),e._v(" "),a("h1",{attrs:{id:"part-iii-protocol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#part-iii-protocol"}},[e._v("#")]),e._v(" Part III - Protocol")]),e._v(" "),a("h2",{attrs:{id:"functions-and-data-defined-in-other-specifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functions-and-data-defined-in-other-specifications"}},[e._v("#")]),e._v(" Functions and Data defined in other Specifications")]),e._v(" "),a("h3",{attrs:{id:"from-the-supervisor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-the-supervisor"}},[e._v("#")]),e._v(" From the "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor_001_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("supervisor"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor_001_draft.md#lc-func-replace-secondary1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LC-FUNC-REPLACE-SECONDARY.1]"),a("OutboundLink")],1)]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"UmVwbGFjZV9TZWNvbmRhcnkoYWRkciBBZGRyZXNzLCByb290LW9mLXRydXN0IExpZ2h0QmxvY2spCg=="}}),e._v(" "),a("h3",{attrs:{id:"from-the-verifier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-the-verifier"}},[e._v("#")]),e._v(" From the "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verifier"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-func-main2",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-FUNC-MAIN.2]"),a("OutboundLink")],1)]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlUb1RhcmdldChwcmltYXJ5IFBlZXJJRCwgcm9vdCBMaWdodEJsb2NrLAogICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCBIZWlnaHQpIChMaWdodFN0b3JlLCBSZXN1bHQpCg=="}}),e._v(" "),a("p",[e._v("Observe that "),a("code",[e._v("VerifyToTarget")]),e._v(" does communication with the secondaries\nvia the function "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-func-fetch1",target:"_blank",rel:"noopener noreferrer"}},[e._v("FetchLightBlock"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"shared-data-of-the-light-client"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shared-data-of-the-light-client"}},[e._v("#")]),e._v(" Shared data of the light client")]),e._v(" "),a("ul",[a("li",[e._v("a pool of full nodes "),a("em",[e._v("FullNodes")]),e._v(" that have not been contacted before")]),e._v(" "),a("li",[e._v("peer set called "),a("em",[e._v("Secondaries")])]),e._v(" "),a("li",[e._v("primary")])]),e._v(" "),a("blockquote",[a("p",[e._v("Note that the lightStore is not needed to be shared.")])]),e._v(" "),a("h2",{attrs:{id:"outline-of-solution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline-of-solution"}},[e._v("#")]),e._v(" Outline of solution")]),e._v(" "),a("p",[e._v("The problem laid out is solved by calling the function "),a("code",[e._v("AttackDetector")]),e._v("\nwith a lightstore that contains a light block that has just been\nverified by the verifier.")]),e._v(" "),a("p",[e._v("Then "),a("code",[e._v("AttackDetector")]),e._v(" downloads headers from the secondaries. In case\na conflicting header is downloaded from a secondary, it calls\n"),a("code",[e._v("CreateEvidenceForPeer")]),e._v(" which computes evidence in the case that\nindeed an attack is confirmed. It could be that the secondary reports\na bogus block, which means that there need not be an attack, and the\nsecondary is replaced.")]),e._v(" "),a("h2",{attrs:{id:"details-of-the-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#details-of-the-functions"}},[e._v("#")]),e._v(" Details of the functions")]),e._v(" "),a("h4",{attrs:{id:"lcd-func-detector-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-func-detector-2"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-FUNC-DETECTOR.2]:")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBBdHRhY2tEZXRlY3Rvcihyb290IExpZ2h0QmxvY2ssIHByaW1hcnlfdHJhY2UgW11MaWdodEJsb2NrKQogICAgICAgICAgICAgICAgICAgKFtdSW50ZXJuYWxFdmlkZW5jZSkgewoKICAgIEV2aWRlbmNlcyA6PSBuZXcgW11JbnRlcm5hbEV2aWRlbmNlOwoKICAgIGZvciBlYWNoIHNlY29uZGFyeSBpbiBTZWNvbmRhcmllcyB7CiAgICAgICAgbGIsIHJlc3VsdCA6PSBGZXRjaExpZ2h0QmxvY2soc2Vjb25kYXJ5LHByaW1hcnlfdHJhY2UuTGF0ZXN0KCkuSGVhZGVyLkhlaWdodCk7CiAgICAgICAgaWYgcmVzdWx0ICE9IFJlc3VsdFN1Y2Nlc3MgewogICAgICAgICAgICBSZXBsYWNlX1NlY29uZGFyeShyb290KTsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiBsYi5IZWFkZXIgIT0gcHJpbWFyeV90cmFjZS5MYXRlc3QoKS5IZWFkZXIgewogIAogICAgICAgICAgICAvLyB3ZSByZXBsYXkgdGhlIHByaW1hcnkgdHJhY2Ugd2l0aCB0aGUgc2Vjb25kYXJ5LCBpbgogICAgICAgICAgICAvLyBvcmRlciB0byBnZW5lcmF0ZSBldmlkZW5jZSB0aGF0IHdlIGNhbiBzdWJtaXQgdG8gdGhlCiAgICAgICAgICAgIC8vIHNlY29uZGFyeS4gV2UgcmV0dXJuIHRoZSBldmlkZW5jZSArIHRoZSB0cmFjZSB0aGUKICAgICAgICAgICAgLy8gc2Vjb25kYXJ5IHRvbGQgdXMgdGhhdCBzcGFucyB0aGUgZXZpZGVuY2UgYXQgaXRzIGxvY2FsIHN0b3JlCgogICAgICAgICAgICBFdmlkZW5jZUZvclNlY29uZGFyeSwgbmV3cm9vdCwgc2Vjb25kYXJ5X3RyYWNlLCByZXN1bHQgOj0KICAgICAgICAgICAgICAgICAgICBDcmVhdGVFdmlkZW5jZUZvclBlZXIoc2Vjb25kYXJ5LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5X3RyYWNlKTsKICAgICAgICAgICAgaWYgcmVzdWx0ID09IEZhdWx0eVBlZXIgewogICAgICAgICAgICAgICAgUmVwbGFjZV9TZWNvbmRhcnkocm9vdCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiByZXN1bHQgPT0gRm91bmRFdmlkZW5jZSB7CiAgICAgICAgICAgICAgICAvLyB0aGUgY29uZmxpY3QgaXMgbm90IGJvZ3VzCiAgICAgICAgICAgICAgICBFdmlkZW5jZXMuQWRkKEV2aWRlbmNlRm9yU2Vjb25kYXJ5KTsKICAgICAgICAgICAgICAgIC8vIHdlIHJlcGxheSB0aGUgc2Vjb25kYXJ5IHRyYWNlIHdpdGggdGhlIHByaW1hcnksIC4uLgogICAgICAgICAgICAgICAgRXZpZGVuY2VGb3JQcmltYXJ5LCBfLCByZXN1bHQgOj0KICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlRXZpZGVuY2VGb3JQZWVyKHByaW1hcnksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdyb290LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5X3RyYWNlKTsKICAgICAgICAgICAgICAgIGlmIHJlc3VsdCA9PSBGb3VuZEV2aWRlbmNlIHsKICAgICAgICAgICAgICAgICAgICBFdmlkZW5jZXMuQWRkKEV2aWRlbmNlRm9yUHJpbWFyeSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGRvIG5vdCBjYXJlIGFib3V0IHRoZSBvdGhlciBlcnJvcgogICAgICAgICAgICAgICAgLy8gY29kZXMuIFdlIGFscmVhZHkgaGF2ZSBnZW5lcmF0ZWQgZXZpZGVuY2UgZm9yIGFuCiAgICAgICAgICAgICAgICAvLyBhdHRhY2sgYW5kIG5lZWQgdG8gc3RvcCB0aGUgbGlnaHRjbGllbnQuIEl0IGRvZXMgbm90CiAgICAgICAgICAgICAgICAvLyBoZWxwIHRvIGNhbGwgcmVwbGFjZV9wcmltYXJ5LiBBbHNvIHdlIHdpbGwgdXNlIHRoZQogICAgICAgICAgICAgICAgLy8gc2FtZSBwcmltYXJ5IHRvIGNoZWNrIHdpdGggb3RoZXIgc2Vjb25kYXJpZXMgaW4KICAgICAgICAgICAgICAgIC8vIGxhdGVyIGl0ZXJhdGlvbnMgb2YgdGhlIGxvb3AKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgc2Vjb25kYXJ5IHJlcG9ydHMgTm9FdmlkZW5jZQogICAgICAgICAgICAvLyBhZnRlciBpbml0aWFsbHkgaXQgcmVwb3J0ZWQgYSBjb25mbGljdGluZyBoZWFkZXIuCiAgICAgICAgICAgIC8vIHNlY29uZGFyeSBpcyBmYXVsdHkKICAgICAgICAgICAgUmVwbGFjZV9TZWNvbmRhcnkocm9vdCk7CiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIEV2aWRlbmNlczsKfQo="}}),e._v(" "),a("ul",[a("li",[e._v("Expected precondition\n"),a("ul",[a("li",[e._v("root and primary trace are a verification trace")])])]),e._v(" "),a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("solves the problem statement (if attack found, then evidence is reported)")])])]),e._v(" "),a("li",[e._v("Error condition\n"),a("ul",[a("li",[a("code",[e._v("ErrorTrustExpired")]),e._v(": fails if root expires (outside trusting\nperiod) "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-inv-tp1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-INV-TP.1]"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("code",[e._v("ErrorNoPeers")]),e._v(": if no peers are left to replace secondaries, and\nno evidence was found before that happened")])])])]),e._v(" "),a("hr"),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBDcmVhdGVFdmlkZW5jZUZvclBlZXIocGVlciBQZWVySUQsIHJvb3QgTGlnaHRCbG9jaywgdHJhY2UgTGlnaHRTdG9yZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAoRXZpZGVuY2UsIExpZ2h0QmxvY2ssIExpZ2h0U3RvcmUsIHJlc3VsdCkgewoKICAgIGNvbW1vbiA6PSByb290OwoKICAgIGZvciBpIGluIDEgLi4gbGVuKHRyYWNlKSB7CiAgICAgICAgYXV4TFMsIHJlc3VsdCA6PSBWZXJpZnlUb1RhcmdldChwZWVyLCBjb21tb24sIHRyYWNlW2ldLkhlYWRlci5IZWlnaHQpCiAgCiAgICAgICAgaWYgcmVzdWx0ICE9IFJlc3VsdFN1Y2Nlc3MgewogICAgICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZzsgcGVlciBkaWQgbm90IHByb3ZpZGUgYSB2ZXJpZmlhYmxlIGJsb2NrCiAgICAgICAgICAgIHJldHVybiAobmlsLCBuaWwsIG5pbCwgRmF1bHR5UGVlcikKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIGF1eExTLkxhdGVzdFZlcmlmaWVkKCkuSGVhZGVyICE9IHRyYWNlW2ldLkhlYWRlciB7CiAgICAgICAgICAgICAgICAvLyB0aGUgaGVhZGVyIHJlcG9ydGVkIGJ5IHRoZSBwZWVyIGRpZmZlcnMgZnJvbSB0aGUKICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBoZWFkZXIgaW4gdHJhY2UgYnV0IGJvdGggY291bGQgYmUKICAgICAgICAgICAgICAgIC8vIHZlcmlmaWVkIGZyb20gY29tbW9uIGluIG9uZSBzdGVwLgogICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNyZWF0ZSBldmlkZW5jZSBmb3Igc3VibWlzc2lvbiB0byB0aGUgc2Vjb25kYXJ5CiAgICAgICAgICAgICAgICBldiA6PSBuZXcgSW50ZXJuYWxFdmlkZW5jZTsKICAgICAgICAgICAgICAgIGV2LkV2aWRlbmNlLkNvbmZsaWN0aW5nQmxvY2sgOj0gdHJhY2VbaV07CiAgICAgICAgICAgICAgICAvLyBDb21tb25IZWlnaHQgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBhdHRhY2sKICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBDb21tb25IZWlnaHQgIT0gQ29uZmxpY3RpbmdCbG9jay5IZWlnaHQgdGhpcyAKICAgICAgICAgICAgICAgIC8vIGlzIGJ5IGRlZmluaXRpb24gYSBsdW5hdGljIGF0dGFjayBlbHNlIGl0IGlzIGFuCiAgICAgICAgICAgICAgICAvLyBlcXVpdm9jYXRpb24gYXR0YWNrCiAgICAgICAgICAgICAgICBldi5FdmlkZW5jZS5Db21tb25IZWlnaHQgOj0gY29tbW9uLkhlaWdodDsKICAgICAgICAgICAgICAgIGV2LlBlZXIgOj0gcGVlcgogICAgICAgICAgICAgICAgcmV0dXJuIChldiwgY29tbW9uLCBhdXhMUywgRm91bmRFdmlkZW5jZSkKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIHRoZSBwZWVyIGFncmVlcyB3aXRoIHRoZSB0cmFjZSwgd2UgbW92ZSBjb21tb24gZm9yd2FyZC4KICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIGRlbGV0ZSBhdXhMUyBhcyBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGluCiAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBpdGVyYXRpb24KICAgICAgICAgICAgICAgIGNvbW1vbiA6PSB0cmFjZVtpXQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIChuaWwsIG5pbCwgbmlsLCBOb0V2aWRlbmNlKQp9Cg=="}}),e._v(" "),a("ul",[a("li",[e._v("Expected precondition\n"),a("ul",[a("li",[e._v("root and trace are a verification trace")])])]),e._v(" "),a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("finds evidence where trace and peer diverge")])])]),e._v(" "),a("li",[e._v("Error condition\n"),a("ul",[a("li",[a("code",[e._v("ErrorTrustExpired")]),e._v(": fails if root expires (outside trusting\nperiod) "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-inv-tp1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-INV-TP.1]"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("VerifyToTarget")]),e._v(" returns error but root is not expired then return\n"),a("code",[e._v("FaultyPeer")])])])])]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"correctness-arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#correctness-arguments"}},[e._v("#")]),e._v(" Correctness arguments")]),e._v(" "),a("h4",{attrs:{id:"on-the-existence-of-evidence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#on-the-existence-of-evidence"}},[e._v("#")]),e._v(" On the existence of evidence")]),e._v(" "),a("p",[a("strong",[e._v("Proposition.")]),e._v(" In the case of attack,\nevidence "),a("a",{attrs:{href:"#TMBC-LC-ATTACK-EVIDENCE1"}},[e._v("[TMBC-LC-ATTACK-EVIDENCE.1]")]),e._v("\nexists."),a("br"),e._v(" "),a("em",[e._v("Proof.")]),e._v(" First observe that")]),e._v(" "),a("ul",[a("li",[e._v("(A). (NOT E2(i)) implies E1(i+1)")])]),e._v(" "),a("p",[e._v("Now by contradiction assume there is no evidence. Thus")]),e._v(" "),a("ul",[a("li",[e._v("for all i, we have NOT E1(i) or NOT E2(i)")]),e._v(" "),a("li",[e._v("for i = 1 we have E1(1) and thus NOT E2(1)\nthus by induction on i, by (A) we have for all i that "),a("strong",[e._v("E1(i)")])]),e._v(" "),a("li",[e._v("from attack we have E2(h-1), and as there is no evidence for\ni = h - 1 we get "),a("strong",[e._v("NOT E1(h-1)")]),e._v(". Contradiction.\nQED.")])]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-inv-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-inv-attack-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-INV-ATTACK1"}},[e._v("[LCD-DIST-INV-ATTACK.1]")])]),e._v(" "),a("p",[e._v("Under the assumption that root and trace are a verification trace,\nwhen in "),a("code",[e._v("CreateEvidenceForPeer")]),e._v(" the detector creates\nevidence, then the lightclient has seen two different headers (one via\n"),a("code",[e._v("trace")]),e._v(" and one via "),a("code",[e._v("VerifyToTarget")]),e._v(") for the same height that can both\nbe verified in one step.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-inv-store-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-inv-store-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-INV-STORE1"}},[e._v("[LCD-DIST-INV-STORE.1]")])]),e._v(" "),a("p",[e._v("We assume that there is at least one correct peer, and there is no\nfork. As a result, the correct peer has the correct sequence of\nblocks. Since the primary_trace is checked block-by-block also against\neach secondary, and at no point evidence was generated that means at\nno point there were conflicting blocks.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-live-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-live-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-LIVE1"}},[e._v("[LCD-DIST-LIVE.1]")])]),e._v(" "),a("p",[e._v("At the latest when "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md#lcv-inv-tp1",target:"_blank",rel:"noopener noreferrer"}},[e._v("[LCV-INV-TP.1]"),a("OutboundLink")],1),e._v(" is violated,\n"),a("code",[e._v("AttackDetector")]),e._v(" terminates.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-term-normal-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-term-normal-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-TERM-NORMAL1"}},[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("p",[e._v("As there are finitely many peers, eventually the main loop\nterminates. As there is no attack no evidence can be generated.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-term-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-term-attack-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-TERM-ATTACK1"}},[e._v("[LCD-DIST-TERM-ATTACK.1]")])]),e._v(" "),a("p",[e._v("Argument similar to  "),a("a",{attrs:{href:"#LCD-DIST-TERM-NORMAL1"}},[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-safe-secondary-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-safe-secondary-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-SAFE-SECONDARY1"}},[e._v("[LCD-DIST-SAFE-SECONDARY.1]")])]),e._v(" "),a("p",[e._v("Secondaries are only replaced if they time-out or if they report bogus\nblocks. The former is ruled out by the timing assumption, the latter\nby correct peers only reporting blocks from the chain.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-safe-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-safe-bogus-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-SAFE-BOGUS1"}},[e._v("[LCD-DIST-SAFE-BOGUS.1]")])]),e._v(" "),a("p",[e._v("Once a bogus block is recognized as such the secondary is removed.")]),e._v(" "),a("h1",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("blockquote",[a("p",[e._v("links to other specifications/ADRs this document refers to")])]),e._v(" "),a("p",[e._v("["),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification_002_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v("] The specification of the light client verification.")]),e._v(" "),a("p",[e._v("["),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor_001_draft.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("supervisor"),a("OutboundLink")],1),e._v("] The specification of the light client supervisor.")])],1)}),[],!1,null,null,null);t.default=r.exports}}]);